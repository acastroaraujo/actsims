---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# actsims

<!-- badges: start -->
[![R-CMD-check](https://github.com/acastroaraujo/actsims/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/acastroaraujo/actsims/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

`actsims` is an ACT package used for internal development of `interactShiny`

## Installation

You can install the development version of actsims like so:

``` r
# install.packages("devtools")
devtools::install_github("acastroaraujo/actsims")
```

## Usage

-   `actsims` is meant to be _fast_ and _easy_ to use.
-   It uses the R6 OOP system to keep better track of EPA ratings and transient impression equations.
-   It is integrated with the `actdata` package.

Create an "InteRactModel" R6 object.

```{r example}
library(actsims)
suppressMessages(library(tidyverse))

act <- interact(dictionary = "usfullsurveyor2015", equations = "us2010")
act
act$equations
act$dictionary
```

This object comes with built in methods which you can access via the `$` operator. 

## Methods

__Deflection scores.__

```{r}
d <- act$deflection(data.frame(A = "god", B = "kill", O = "deadbeat"))
d
```

You can also extract useful metadata from these scores.

```{r}
get_fundamentals(d)
get_transients(d)
get_element_wise_deflection(d)
```

__Behaviors__

```{r}
act$optimal_behavior(d, who = "actor")
act$optimal_behavior(d, who = "object")
```

__Re-identification__

```{r}
act$reidentify(d, who = "actor")
act$reidentify(d, who = "object")
```

__Solve For...__

```{r}
act$max_confirm(
  events = tibble(A = "god", O = "deadbeat"), 
  solve_for = "behavior"
) 

act$max_confirm(
  events = list(A = "god", B = "kill"), 
  solve_for = "object"
) 

act$max_confirm(
  events = data.frame(B = "kill", O = "deadbeat"), 
  solve_for = "actor"
) 

```

__Closest Terms__

```{r}
act$closest_terms(list(e = 1, p = 0, a = -1), component = "behavior", max_dist = 0.5)

## Closest term to deadbeat (stored in d object)
deadbeat <- get_fundamentals(d) |> select(matches("O")) 
deadbeat
act$closest_terms(epa = deadbeat, component = "modifier", max_dist = 0.5)
```

## In Bulk...

You can use a grid of events to estimate multiple deflection scores simultaneously.

For example, the following `events` object contains 4 million ABO events randomly created from the `usfullsurveyor2015` dictionary. 

```{r}
# create a grid of specific AB0s
events <- tidyr::crossing(
  A = dplyr::filter(act$dictionary, component == "identity")[["term"]] |> sample(200),
  B = dplyr::filter(act$dictionary, component == "behavior")[["term"]] |> sample(100),
  O = dplyr::filter(act$dictionary, component == "identity")[["term"]] |> sample(200)
) 

glimpse(events)
```

Every method, with the exception of `$closest_terms()`, is designed to work in bulk. However, only the `$deflection()` method will work fast with millions of observations. Other methods might require a minute or so...

```{r}
d <- act$deflection(events)
d
```


## Deference Score

You can also create the deference scores discussed by Freeland & Hoey (2018). But this requires to set up a new dictionary. 

You'll have to do with the help of some external packages.

For example:

```{r}
occupation_ratings <- actdata::epa_subset(dataset = "occs2019") |> 
  dplyr::select(term, component, E, P, A) |> 
  dplyr::rename_all(tolower) |> 
  dplyr::rowwise() |> 
  dplyr::mutate(ratings = list(c(e = e, p = p, a = a))) |> 
  dplyr::ungroup() |> 
  dplyr::select(term, component, ratings)

defer_to <- act$dictionary |> 
  dplyr::filter(term == "defer_to")

# Then you'll have to replace the original dictionary.

act$dictionary <- dplyr::bind_rows(defer_to, occupation_ratings)
```

Note that a message appeared signaling that the replacement was succesful.

```{r}
act
```

Now you just create another grid of events, calculate the deflection scores, and average over the As.

```{r}
events <- tidyr::crossing(
  A = occupation_ratings$term,
  B = "defer_to",
  O = occupation_ratings$term
)

output <- act$deflection(events)

output |> 
  group_by(A) |> 
  summarize(avg = mean(deflection), sd = sd(deflection)) |> 
  arrange(desc(avg)) 
```



