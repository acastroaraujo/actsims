---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# actsims

<!-- badges: start -->
[![R-CMD-check](https://github.com/acastroaraujo/actsims/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/acastroaraujo/actsims/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

`actsims` is an ACT package used for internal development of `interactShiny`

**It is not meant for public consumption.**

## Installation

However, if you must insist...

You can install the development version of actsims like so:

``` r
# install.packages("devtools")
devtools::install_github("acastroaraujo/actsims")
```

## Usage

-   `actsims` is meant to be fast and easy to use.
-   It uses the R6 OOP system to keep better track of EPA ratings and transient impression equations.
-   It is integrated with the `actdata` package.

Create an "InteRactModel" R6 object.

```{r example}
library(actsims)
suppressMessages(library(tidyverse))

act <- interact(dictionary = "usfullsurveyor2015", equations = "us2010")
act
act$equations
act$dictionary
```

## Methods

This object comes with built in methods which you can access via the `$` operator. 

__Deflection scores.__

```{r}
d <- act$deflection(list(A = "god", B = "kill", O = "deadbeat"))
d
```

You can also extract useful metadata from these scores.

```{r}
get_fundamentals(d)
get_transients(d)
get_element_wise_deflection(d)
```

__Behaviors__

```{r}
act$optimal_behavior_actor(d)
act$optimal_behavior_object(d)
```

__Re-identification__

```{r}
act$reidentify_actor(d)
act$reidentify_object(d)
```

__Solve For...__

```{r}
act$max_confirm(
  events = data.frame(A = "god", O = "deadbeat"), 
  solve_for = "behavior"
) 

act$max_confirm(
  events = data.frame(A = "god", B = "kill"), 
  solve_for = "object"
) 

act$max_confirm(
  events = data.frame(B = "kill", O = "deadbeat"), 
  solve_for = "actor"
) 

```

__Closest Terms__

```{r}
act$closest_terms(list(e = 1, p = 0, a = -1), component = "behavior", max_dist = 0.5)

## Closest term to deadbeat (stored in d object)
deadbeat <- get_fundamentals(d) |> select(matches("O")) 
deadbeat
act$closest_terms(epa = deadbeat, component = "modifier", max_dist = 0.5)
```

## In Bulk...

You can use a grid of events to estimate multiple deflection scores simultaneously.

For example, the following `events` object contains more than 2 million ABO events randomly created from the `usfullsurveyor2015` dictionary. 

```{r}
# create a grid of specific AB0s
events <- tidyr::crossing(
  A = act$dictionary |> dplyr::filter(component == "identity") |> dplyr::pull(term),
  B = act$dictionary |> dplyr::filter(component == "behavior") |> dplyr::pull(term) |> sample(3),
  O = act$dictionary |> dplyr::filter(component == "identity") |> dplyr::pull(term)
) 

glimpse(events)
```

Every method, with the exception of `$closest_terms()`, is designed to work in bulk. However, only the `$deflection()` method will work fast with millions of observations. Other methods might require a few minutes...

```{r}
d <- act$deflection(events)
d
```


## Deference Score

You can also create the deference scores discussed by Freeland & Hoey (2018). But this requires to set up a new dictionary. 

You'll have to do with the help of some external packages.

For example:

```{r}
occupation_ratings <- actdata::epa_subset(dataset = "occs2019") |> 
  dplyr::select(term, component, E, P, A) |> 
  dplyr::rename_all(tolower) |> 
  dplyr::rowwise() |> 
  dplyr::mutate(ratings = list(c(e = e, p = p, a = a))) |> 
  dplyr::ungroup() |> 
  dplyr::select(term, component, ratings)

occupation_ratings

defer_to <- act$dictionary |> 
  dplyr::filter(term == "defer_to")
```

Then you'll have to replace the original dictionary.

```{r}
act$dictionary <- dplyr::bind_rows(defer_to, occupation_ratings)
```

Note that a message appeared signaling that the replacement was succesful.

```{r}
act
```

Now you just create another grid of events, calculate the deflection scores, and average over the As.

```{r}
events <- crossing(
  A = occupation_ratings$term,
  B = "defer_to",
  O = occupation_ratings$term
)

output <- act$deflection(events)

output |> 
  group_by(A) |> 
  summarize(avg = mean(deflection), sd = sd(deflection)) |> 
  arrange(desc(avg)) 
```

